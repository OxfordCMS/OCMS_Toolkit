name: Version & Tag on Merge

on:
  pull_request:
    types: [opened, synchronize, labeled, unlabeled]
  push:
    branches: [main]

permissions:
  contents: write
  pull-requests: read

jobs:
  # Update setup.py on PR branch (before merge)
  bump_version_on_pr:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      # Checkout PR branch to make changes before merge
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      # Configure git author for commits
      - run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # Extract version bump level from PR labels (major, minor, or patch)
      - name: Get bump level from PR labels
        id: bump_level
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(l => l.name.toLowerCase());
            let level = 'patch'; // default to patch if no label found
            if (labels.includes('major')) level = 'major';
            else if (labels.includes('minor')) level = 'minor';
            core.setOutput('level', level);
            core.info(`Detected bump level: ${level} (labels: ${labels.join(', ')})`);

      # Get latest tag and calculate the next version number
      - name: Calculate next version
        id: next_version
        run: |
          # Fetch latest version tag (v*.*.* format)
          latest=$(git describe --tags --abbrev=0 2>/dev/null | grep -E 'v[0-9]+\.[0-9]+\.[0-9]+' | tail -1 || echo "v0.0.0")
          version=${latest#v}
          IFS='.' read -r major minor patch <<<"$version"
          major=${major:-0}
          minor=${minor:-0}
          patch=${patch:-0}

          # Increment version based on bump level
          level="${{ steps.bump_level.outputs.level }}"
          case $level in
            major) major=$((major + 1)); minor=0; patch=0 ;;
            minor) minor=$((minor + 1)); patch=0 ;;
            *) patch=$((patch + 1)) ;;
          esac

          next_version="$major.$minor.$patch"
          echo "version=$next_version" >> "$GITHUB_OUTPUT"
          echo "New version: $next_version"

      # Update setup.py with calculated version and push to PR branch
      # Only commits if version differs from current to avoid duplicate bumps on label changes
      - name: Update setup.py and commit to PR branch
        run: |
          new_version="${{ steps.next_version.outputs.version }}"
          current_version=$(sed -n 's/.*version="\([^"]*\)".*/\1/p' setup.py)
          
          # Skip commit if version is already correct (prevents duplicate bumps on label changes)
          if [ "$current_version" = "$new_version" ]; then
            echo "Version already at $new_version, skipping commit"
            exit 0
          fi
          
          # Update version in setup.py
          sed -i "s/version=\"[^\"]*\"/version=\"$new_version\"/" setup.py
          git add setup.py
          git commit -m "chore: bump version to $new_version"
          git push origin HEAD:${{ github.head_ref }}

  # Create annotated git tag on push to main (after PR merge)
  tag_on_merge:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      # Checkout main branch at merge commit
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # Configure git author for tagging
      - run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # Read version from setup.py and create tag pointing to merge commit
      - name: Create version tag from setup.py
        run: |
          # Extract version from setup.py
          version=$(sed -n 's/.*version="\([^"]*\)".*/\1/p' setup.py)
          if [ -z "$version" ]; then
            echo "Could not extract version from setup.py" >&2
            exit 1
          fi
          
          # Derive tag name from version
          tag="v$version"
          
          # Ensure we know about all remote tags
          git fetch --tags
          
          # If the tag already exists locally or on the remote, skip creating it
          if git rev-parse "$tag" >/dev/null 2>&1; then
            echo "Tag $tag already exists locally, skipping tag creation"
            exit 0
          fi
          if git ls-remote --tags origin "$tag" | grep -q "$tag"; then
            echo "Tag $tag already exists on remote, skipping tag creation"
            exit 0
          fi
          
          # Create annotated tag and push to origin
          git tag -a "$tag" -m "Release $tag"
          git push origin "$tag"
          echo "âœ… Tagged commit with $tag"
