name: Version & Tag on Merge

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      version_level:
        description: "Version bump level"
        type: choice
        options: [patch, minor, major]
        default: patch

permissions:
  contents: write

jobs:
  bump_version_and_tag:
    runs-on: ubuntu-latest
    steps:
      # Checkout the current state of main after merge
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PUSH_TOKEN || secrets.GITHUB_TOKEN }}

      # Configure git for commits and tagging
      - run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # Determine version bump level from PR label (if triggered by push) or manual input
      - name: Get bump level from PR label or input
        id: bump_level
        uses: actions/github-script@v7
        with:
          script: |
            // For manual dispatch, use the provided input
            if (context.eventName === 'workflow_dispatch') {
              const level = context.payload.inputs.version_level || 'patch';
              core.setOutput('level', level);
              core.info(`Manual trigger: using ${level}`);
              return;
            }

            // For push event, extract PR label from commit
            const commit = await github.rest.git.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha
            });
            
            // Try to find associated PR for this commit
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 10
            });

            let level = 'patch'; // default
            for (const pr of prs.data) {
              if (pr.merge_commit_sha === context.sha) {
                const labels = pr.labels.map(l => l.name.toLowerCase());
                if (labels.includes('major')) level = 'major';
                else if (labels.includes('minor')) level = 'minor';
                core.info(`Found PR #${pr.number} with labels: ${labels.join(', ')} → bump: ${level}`);
                break;
              }
            }
            
            core.setOutput('level', level);

      # Get latest version tag and compute next version
      - name: Calculate next version
        id: next_version
        run: |
          # Get latest tag matching v*.*.* pattern
          latest=$(git describe --tags --abbrev=0 2>/dev/null | grep -E 'v[0-9]+\.[0-9]+\.[0-9]+' | tail -1 || echo "v0.0.0")
          echo "Latest tag: $latest"

          # Parse version
          version=${latest#v}
          IFS='.' read -r major minor patch <<<"$version"
          major=${major:-0}
          minor=${minor:-0}
          patch=${patch:-0}

          # Apply bump
          level="${{ steps.bump_level.outputs.level }}"
          case $level in
            major) major=$((major + 1)); minor=0; patch=0 ;;
            minor) minor=$((minor + 1)); patch=0 ;;
            *) patch=$((patch + 1)) ;;
          esac

          next_version="$major.$minor.$patch"
          next_tag="v$next_version"
          
          echo "version=$next_version" >> "$GITHUB_OUTPUT"
          echo "tag=$next_tag" >> "$GITHUB_OUTPUT"
          echo "New version: $next_tag"

      # Update setup.py with new version and commit
      - name: Update version in setup.py and commit
        run: |
          new_version="${{ steps.next_version.outputs.version }}"
          sed -i "s/version=\"[^\"]*\"/version=\"$new_version\"/" setup.py
          
          git add setup.py
          git commit -m "chore: bump version to $new_version" || echo "No version changes"
          git push origin main

      # Create annotated tag at the merge commit
      - name: Create and push version tag
        run: |
          tag="${{ steps.next_version.outputs.tag }}"
          git tag -a "$tag" -m "Release $tag"
          git push origin "$tag"
          echo "✅ Tagged commit with $tag"
