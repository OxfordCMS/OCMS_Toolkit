name: Bump version in PR & ensure tag points to merge commit

on:
  repository_dispatch:
    types: [tag_on_merge]
  workflow_dispatch:
    inputs:
      version_level:
        description: "Manual bump level"
        required: false
        default: patch
        type: choice
        options:
          - patch
          - minor
          - major
  push:
    branches:
      - main

permissions:
  contents: write

env:
  # Optional: if your org blocks GITHUB_TOKEN writes, set a PAT in secrets.PUSH_TOKEN
  PUSH_TOKEN: ${{ secrets.PUSH_TOKEN || '' }}
  REPO: ${{ github.repository }}

jobs:
  bump_and_tag:
    # Runs for: repository_dispatch (from validate), manual workflow_dispatch, or push to main
    if: |
      github.event_name == 'repository_dispatch' ||
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    env:
      # For repository_dispatch from validate workflow, use client_payload; otherwise use workflow_dispatch input
      PR_BRANCH: ${{ github.event.client_payload.pr_branch || github.ref_name }}
      PR_NUMBER: ${{ github.event.client_payload.pr_number || '' }}
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.client_payload.pr_branch || github.ref_name }}
          fetch-depth: 0

      - name: Use PAT for pushes if provided
        run: |
          if [ -n "${PUSH_TOKEN}" ]; then
            echo "Using PUSH_TOKEN for pushes"
            git remote set-url origin https://x-access-token:${PUSH_TOKEN}@github.com/${REPO}.git
          else
            echo "Using default runner auth (GITHUB_TOKEN)"
          fi

      - name: Fetch tags from origin
        run: git fetch --tags --force

      - name: Get latest tag
        id: get_latest
        run: |
          latest=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $latest"
          echo "latest_tag=$latest" >> "$GITHUB_OUTPUT"

      - name: Determine bump level and candidate tag (reads labels via REST API)
        id: determine
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // core and github are already available globally in actions/github-script
            
            // Extract PR number from payload
            const prNumber = github.context.payload.client_payload?.pr_number 
              || github.context.payload.pull_request?.number;

            if (prNumber) {
              core.info(`Found PR number: ${prNumber}`);
            } else {
              core.warning("No PR number found; will use default bump level");
            }

            // Fetch labels for the PR if we have a PR number
            let labels = [];
            if (prNumber) {
              try {
                const res = await github.rest.issues.listLabelsOnIssue({
                  owner: github.context.repo.owner,
                  repo: github.context.repo.repo,
                  issue_number: prNumber
                });
                labels = res.data.map(l => l.name.toLowerCase());
                core.info(`Fetched labels: ${labels.join(', ')}`);
              } catch (error) {
                core.warning(`Failed to fetch labels: ${error.message}`);
              }
            }

            // Determine bump level: workflow_dispatch input > labels > default
            const eventName = github.context.eventName;
            const inputLevel = process.env.INPUT_VERSION_LEVEL;
            
            let level = 'patch'; // default
            
            if (eventName === "workflow_dispatch" && inputLevel) {
              level = inputLevel;
              core.info(`Using workflow_dispatch input: ${level}`);
            } else {
              // Check for label matches (major > minor > patch)
              if (labels.some(l => l.includes('major'))) level = 'major';
              else if (labels.some(l => l.includes('minor'))) level = 'minor';
              else if (labels.some(l => l.includes('patch'))) level = 'patch';
            }

            core.info(`Determined bump level: ${level}`);

            // Parse latest tag and calculate new version
            const latest = process.env.LATEST_TAG || 'v0.0.0';
            const versionStr = latest.replace(/^v/, '');
            const [major = 0, minor = 0, patch = 0] = versionStr.split('.').map(x => parseInt(x, 10) || 0);

            let newMajor = major, newMinor = minor, newPatch = patch;
            if (level === 'major') {
              newMajor += 1;
              newMinor = 0;
              newPatch = 0;
            } else if (level === 'minor') {
              newMinor += 1;
              newPatch = 0;
            } else {
              newPatch += 1;
            }

            const candidate = `v${newMajor}.${newMinor}.${newPatch}`;
            core.setOutput('bump_level', level);
            core.setOutput('candidate_tag', candidate);
            core.setOutput('detected_labels', labels.join(','));
        env:
          LATEST_TAG: ${{ steps.get_latest.outputs.latest_tag }}
          INPUT_VERSION_LEVEL: ${{ github.event.inputs.version_level || '' }}

      - name: Reserve unique tag by looping & update setup.py to match
        id: reserve_and_push
        shell: bash
        run: |
          set -euo pipefail

          increment_patch() {
            v="$1"
            v="${v#v}"
            IFS='.' read -r maj min pat <<<"$v"
            pat=$((pat + 1))
            echo "v${maj}.${min}.${pat}"
          }

          branch="${PR_BRANCH}"
          candidate="${{ steps.determine.outputs.candidate_tag }}"
          echo "Starting candidate: $candidate"
          while true; do
            echo "Checking remote for tag: $candidate"
            git fetch --tags --force

            # Check remote for existence of the candidate tag
            if git ls-remote --tags origin "$candidate" | grep -q "refs/tags/$candidate"; then
              echo "Tag $candidate already exists on remote — incrementing patch and trying again"
              candidate=$(increment_patch "$candidate")
              echo "New candidate: $candidate"
              continue
            fi

            clean="${candidate#v}"
            echo "Updating setup.py to version $clean"

            # Replace only the numeric version portion, preserving quotes (matches your setup.py)
            sed -i -E "s/(version\s*=\s*['\"])[0-9]+\.[0-9]+\.[0-9]+(['\"])/\1$clean\2/" setup.py

            if git diff --quiet; then
              echo "No changes to commit (setup.py already at $clean)"
            else
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add setup.py
              git commit -m "chore: bump version to ${candidate}" || true
              echo "Pushing commit to PR branch ${branch}"
              git push origin "HEAD:${branch}"
            fi

            # create (or recreate) local tag and push
            if git rev-parse --verify --quiet "$candidate" >/dev/null; then
              git tag -d "$candidate" || true
            fi
            git tag -a "$candidate" -m "Release $candidate"

            echo "Pushing tag $candidate to origin"
            if git push origin "$candidate"; then
              echo "Successfully pushed tag $candidate"
              echo "final_tag=$candidate" >> "$GITHUB_OUTPUT"
              echo "final_version=${candidate#v}" >> "$GITHUB_OUTPUT"
              break
            else
              echo "Tag push failed (likely race). Deleting local tag and incrementing patch to retry."
              git tag -d "$candidate" || true
              candidate=$(increment_patch "$candidate")
            fi
          done

      - name: Output result
        run: |
          echo "Version set in PR: ${{ steps.reserve_and_push.outputs.final_version }}"
          echo "Tag created (provisional at PR commit): ${{ steps.reserve_and_push.outputs.final_tag }}"

  repoint_tag_on_push:
    # only run for real pushes to main
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read version from setup.py
        id: version
        run: |
          ver=$(sed -n -E "s/.*version\s*=\s*['\"]([0-9]+\.[0-9]+\.[0-9]+)['\"].*/\1/p" setup.py)
          if [ -z "$ver" ]; then
            echo "Could not extract version from setup.py" >&2
            exit 1
          fi
          echo "version=$ver" >> "$GITHUB_OUTPUT"
          echo "tag=v$ver" >> "$GITHUB_OUTPUT"
          echo "Detected version: v$ver"

      - name: Move or create tag to point at merge commit
        env:
          PUSH_TOKEN: ${{ secrets.PUSH_TOKEN || '' }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          GHTOKEN="${PUSH_TOKEN:-${GITHUB_TOKEN}}"
          MAIN_SHA=$(git rev-parse HEAD)
          TAG="${{ steps.version.outputs.tag }}"

          echo "Updating tag $TAG to point to commit $MAIN_SHA"

          # check if tag ref exists
          status=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $GHTOKEN" \
            "https://api.github.com/repos/${REPO}/git/refs/tags/${TAG}")

          if [ "$status" = "200" ]; then
            echo "Tag exists; moving it to new commit"
            curl -s -X PATCH \
              -H "Authorization: token $GHTOKEN" \
              -H "Accept: application/vnd.github+json" \
              -d "{\"sha\":\"${MAIN_SHA}\",\"force\":true}" \
              "https://api.github.com/repos/${REPO}/git/refs/tags/${TAG}"
          elif [ "$status" = "404" ]; then
            echo "Tag not found; creating it at main commit"
            curl -s -X POST \
              -H "Authorization: token $GHTOKEN" \
              -H "Accept: application/vnd.github+json" \
              -d "{\"ref\":\"refs/tags/${TAG}\",\"sha\":\"${MAIN_SHA}\"}" \
              "https://api.github.com/repos/${REPO}/git/refs"
          else
            echo "Unexpected status ${status} from GitHub API when checking tag; aborting"
            exit 1
          fi

          echo "✅ Tag ${TAG} now points to the merge commit ${MAIN_SHA}"