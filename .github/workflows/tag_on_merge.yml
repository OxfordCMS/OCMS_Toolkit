name: Bump version in PR & ensure tag points to merge commit

on:
  workflow_dispatch:
    inputs:
      version_level:
        description: "Manual bump level"
        required: false
        default: patch
        type: choice
        options:
          - patch
          - minor
          - major
  workflow_run:
    workflows: ["Validate PR Labels"]
    types: [completed]

permissions:
  contents: write

env:
  # Optional: if your org blocks GITHUB_TOKEN writes, set a PAT in secrets.PUSH_TOKEN
  PUSH_TOKEN: ${{ secrets.PUSH_TOKEN || '' }}
  REPO: ${{ github.repository }}

jobs:
  bump_and_tag:
    if: >
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
      || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    env:
      # set PR branch + head repo from workflow_run payload (available here)
      PR_BRANCH: ${{ github.event.workflow_run.head_branch }}
      PR_REPOSITORY: ${{ github.event.workflow_run.head_repository.full_name }}
    steps:
      - name: Checkout PR branch (head)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.workflow_run.head_repository.full_name }}
          ref: ${{ github.event.workflow_run.head_branch }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Use PAT for pushes if provided
        run: |
          if [ -n "${PUSH_TOKEN}" ]; then
            echo "Using PUSH_TOKEN for pushes"
            git remote set-url origin https://x-access-token:${PUSH_TOKEN}@github.com/${REPO}.git
          else
            echo "Using default runner auth (GITHUB_TOKEN)"
          fi

      - name: Fetch tags from origin
        run: git fetch --tags --force

      - name: Get latest tag
        id: get_latest
        run: |
          latest=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $latest"
          echo "latest_tag=$latest" >> "$GITHUB_OUTPUT"

      - name: Determine bump level and candidate tag (reads labels via REST API)
        id: determine
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');
            const github = require('@actions/github');

            // Try to extract PR number from workflow_run payload
            const wf = github.context.payload.workflow_run || {};
            let prNumber = undefined;
            if (wf.pull_requests && wf.pull_requests.length > 0) {
              prNumber = wf.pull_requests[0].number;
            }
            // Fallback if this run was manually dispatched with a PR payload (unlikely)
            if (!prNumber && github.context.payload.pull_request) {
              prNumber = github.context.payload.pull_request.number;
            }

            // Fetch labels for the PR if we have a PR number
            let labels = [];
            if (prNumber) {
              const res = await github.getOctokit(core.getInput('token') || process.env.GITHUB_TOKEN).rest.issues.listLabelsOnIssue({
                owner: github.context.repo.owner,
                repo: github.context.repo.repo,
                issue_number: prNumber
              });
              labels = res.data.map(l => l.name.toLowerCase());
            } else {
              core.info("No PR number in workflow_run payload; falling back to inputs/env.");
            }

            // Choose bump level: prefer workflow_dispatch input if present; otherwise detect from labels
            const eventName = github.context.eventName;
            const inputLevel = process.env.INPUT_VERSION_LEVEL || '';
            let level = '';
            if (eventName === "workflow_dispatch" && inputLevel) {
              level = inputLevel;
            } else if (labels.includes('major')) {
              level = 'major';
            } else if (labels.includes('minor')) {
              level = 'minor';
            } else if (labels.includes('patch')) {
              level = 'patch';
            } else {
              // substring fallback (handles release:major etc)
              if (labels.some(l => l.includes('major'))) level = 'major';
              else if (labels.some(l => l.includes('minor'))) level = 'minor';
              else level = 'patch';
            }

            core.info(`Determined bump level: ${level} (labels: ${labels.join(',')})`);

            // Get latest tag from env passed in
            const latest = process.env.LATEST_TAG || 'v0.0.0';
            let vs = latest.startsWith('v') ? latest.slice(1) : latest;
            let parts = vs.split('.').map(x => parseInt(x, 10));
            let [major, minor, patch] = parts;
            if (isNaN(major)) major = 0;
            if (isNaN(minor)) minor = 0;
            if (isNaN(patch)) patch = 0;

            if (level === 'major') { major += 1; minor = 0; patch = 0; }
            else if (level === 'minor') { minor += 1; patch = 0; }
            else { patch += 1; }

            const candidate = `v${major}.${minor}.${patch}`;
            core.setOutput('bump_level', level);
            core.setOutput('candidate_tag', candidate);
            core.setOutput('detected_labels', labels.join(','));
            console.log(`candidate_tag=${candidate}`);
        env:
          LATEST_TAG: ${{ steps.get_latest.outputs.latest_tag }}
          INPUT_VERSION_LEVEL: ${{ github.event.inputs.version_level || '' }}

      - name: Reserve unique tag by looping & update setup.py to match
        id: reserve_and_push
        shell: bash
        run: |
          set -euo pipefail

          increment_patch() {
            v="$1"
            v="${v#v}"
            IFS='.' read -r maj min pat <<<"$v"
            pat=$((pat + 1))
            echo "v${maj}.${min}.${pat}"
          }

          branch="${PR_BRANCH:-${{ github.event.workflow_run.head_branch }}}"
          candidate="${{ steps.determine.outputs.candidate_tag }}"
          echo "Starting candidate: $candidate"
          while true; do
            echo "Checking remote for tag: $candidate"
            git fetch --tags --force

            # Check remote for existence of the candidate tag
            if git ls-remote --tags origin "$candidate" | grep -q "refs/tags/$candidate"; then
              echo "Tag $candidate already exists on remote — incrementing patch and trying again"
              candidate=$(increment_patch "$candidate")
              echo "New candidate: $candidate"
              continue
            fi

            clean="${candidate#v}"
            echo "Updating setup.py to version $clean"

            # Replace only the numeric version portion, preserving quotes (matches your setup.py)
            sed -i -E "s/(version\s*=\s*['\"])[0-9]+\.[0-9]+\.[0-9]+(['\"])/\1$clean\2/" setup.py

            if git diff --quiet; then
              echo "No changes to commit (setup.py already at $clean)"
            else
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add setup.py
              git commit -m "chore: bump version to ${candidate}" || true
              echo "Pushing commit to PR branch ${branch}"
              git push origin "HEAD:${branch}"
            fi

            # create (or recreate) local tag and push
            if git rev-parse --verify --quiet "$candidate" >/dev/null; then
              git tag -d "$candidate" || true
            fi
            git tag -a "$candidate" -m "Release $candidate"

            echo "Pushing tag $candidate to origin"
            if git push origin "$candidate"; then
              echo "Successfully pushed tag $candidate"
              echo "final_tag=$candidate" >> "$GITHUB_OUTPUT"
              echo "final_version=${candidate#v}" >> "$GITHUB_OUTPUT"
              break
            else
              echo "Tag push failed (likely race). Deleting local tag and incrementing patch to retry."
              git tag -d "$candidate" || true
              candidate=$(increment_patch "$candidate")
            fi
          done

      - name: Output result
        run: |
          echo "Version set in PR: ${{ steps.reserve_and_push.outputs.final_version }}"
          echo "Tag created (provisional at PR commit): ${{ steps.reserve_and_push.outputs.final_tag }}"

  repoint_tag_on_push:
    # only run for real pushes to main
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read version from setup.py
        id: version
        run: |
          ver=$(sed -n -E "s/.*version\s*=\s*['\"]([0-9]+\.[0-9]+\.[0-9]+)['\"].*/\1/p" setup.py)
          if [ -z "$ver" ]; then
            echo "Could not extract version from setup.py" >&2
            exit 1
          fi
          echo "version=$ver" >> "$GITHUB_OUTPUT"
          echo "tag=v$ver" >> "$GITHUB_OUTPUT"
          echo "Detected version: v$ver"

      - name: Move or create tag to point at merge commit
        env:
          PUSH_TOKEN: ${{ secrets.PUSH_TOKEN || '' }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          GHTOKEN="${PUSH_TOKEN:-${GITHUB_TOKEN}}"
          MAIN_SHA=$(git rev-parse HEAD)
          TAG="${{ steps.version.outputs.tag }}"

          echo "Updating tag $TAG to point to commit $MAIN_SHA"

          # check if tag ref exists
          status=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $GHTOKEN" \
            "https://api.github.com/repos/${REPO}/git/refs/tags/${TAG}")

          if [ "$status" = "200" ]; then
            echo "Tag exists; moving it to new commit"
            curl -s -X PATCH \
              -H "Authorization: token $GHTOKEN" \
              -H "Accept: application/vnd.github+json" \
              -d "{\"sha\":\"${MAIN_SHA}\",\"force\":true}" \
              "https://api.github.com/repos/${REPO}/git/refs/tags/${TAG}"
          elif [ "$status" = "404" ]; then
            echo "Tag not found; creating it at main commit"
            curl -s -X POST \
              -H "Authorization: token $GHTOKEN" \
              -H "Accept: application/vnd.github+json" \
              -d "{\"ref\":\"refs/tags/${TAG}\",\"sha\":\"${MAIN_SHA}\"}" \
              "https://api.github.com/repos/${REPO}/git/refs"
          else
            echo "Unexpected status ${status} from GitHub API when checking tag; aborting"
            exit 1
          fi

          echo "✅ Tag ${TAG} now points to the merge commit ${MAIN_SHA}"
